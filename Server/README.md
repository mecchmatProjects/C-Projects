# tcpip
TCP/IP client/server (support many clients)

______________________________________________________
Сервер
______________________________________________________

Стандартні дії та їх логіку по створенню клієнта я описала
в рефераті і позначила їх межі коментарями у коді. Тут я опишу 
деякі додаткові рішення специфічні для конкретно цього 
завдання і можливо трохи більш продвинуті.

Оскільки кожен клієнт має мати свій ідентифікатор зареєстрований
на сервері, то я створюю масив clients_id де і-тому місці
стоїть ідентифікатор того клієнта, якого обслуговує і-тий
файловий дескриптор. По ходу програми саме за допомогою
цього масива реалізовується зв'зка ідентифікатора клаєнта
та номером файлового дескриптора через який помжна надсилати/
приймати повідомлення і таким чином я уникаю двомірних масивів
для цієї задачі.

Всі наступні дії детально описані в коментарях у коді.

________________________________________________________
Клієнт
________________________________________________________

Стандартні дії та їх логіку по створенню клієнта я описав
в рефераті і позначив їх межі коментарями у коді. Тут я опишу 
деякі додаткові рішення специфічні для конкретно цього 
завдання і можливо трохи більш продвинуті.

Функції writeToServer та readFromServer досить тривіальні:
одна постійно чекає ввід в консоль від користувача, а інша 
постійно перевіряє чи сервер нічого не відправив та якщо 
відправив -- виводить на екран.

Для початку варто зрозуміти, що наш клієнт має приймати 
повідомлення від сервера постійно, а не лише, так би мовити, 
"парами" (сам надіслав дані, а тоді чекає відповіді від сервера).
Я реалізувала незалежність процесів прийняття і відправки
даних у клієнті за допомогою виділення двох додаткових потоків:
один з яких забезпечує перманентну роботу функції writeToServer(),
а інший роботу readFromServer().

Створення нових процесів відбувається досить просто за допомогою
ф-ції pthread_create() (хедерфайл pthread.h).

Для того, щоб гарненько вийти з програми і просто потренуватись 
перехоплювати сигнали я створила змінну flag (додав до неї кваліфікатор
volatile -- він зберігає змінну від оптимізації процесором, адже 
процесор може перемістити її в кеш, що додасть деякі складнощі
у доступі до неї з різних процесів, а процесів у нас вже більше одного).
Отже під час натискання ctrl+c флаг змінює своє значення на 1 --
нескінченний цикл завершується.
