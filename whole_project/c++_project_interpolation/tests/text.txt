#include "../headers/interpolation.h"
#include <stdio.h>
#include <stdlib.h>

int main(){
    printf("Welcome to my Interpolation Project\n");

    printf("Please choose input type: \n"); 
    printf("c/t - console/text file \n");

    character work_type;
    scanf(" %c",&work_type);
    integer wrong_input_flag = work_type == 'c' | work_type == 't';
    while (wrong_input_flag==0) {
        printf("Please choose correct input type: \n");
        printf("c/t - console/text file \n");
        scanf(" %c",&work_type);
        wrong_input_flag = work_type == 'c' | work_type == 't';
    }

    struct DVector x,y;
    struct Input_Data inputData = {0, &x, &y};
    struct DVector ans_linear;
    Functions functions;
//    struct DVector ans_cubic;
    character *filename = (character *) malloc(100 * sizeof(character));

    if(work_type == 'c') {
        if (!functions.input(&inputData)) { // exit code == 0 => it's ok
            ans_linear = functions.Calculate  (&inputData);
//            ans_cubic  = Interpolate(&inputData);
        } else {
            return 1;
        }
    } else if (work_type == 't') {
        printf("Please write a filename:\n");
        scanf(" %s", filename);
        if (!functions.inputTextFile(filename, &inputData)) { // exit code == 0 => it's ok
            ans_linear = functions.Calculate(&inputData);
//            ans_cubic  = functions.Interpolate(&inputData);
        } else {
            return 1;
        }
    }

    printf("Please choose output type: \n");
    printf("c/t/b - console/binary file/text file \n");
    scanf(" %c",&work_type);
    wrong_input_flag = work_type == 'c' || work_type == 't' || work_type == 'b';
    while (wrong_input_flag == 0) {
        printf("Please choose correct output type: \n");
        printf("c/b/t - console/binary file/text file \n");
        scanf(" %c",&work_type);
        wrong_input_flag = work_type == 'c' | work_type == 't' | work_type == 'b';
    }

    if(work_type == 'c') {
        functions.output(&ans_linear);
//        functions.output(&ans_cubic);
    } else if(work_type == 'b') {
        printf("Please write a filename:\n");
        scanf("%s", filename);
        functions.outputBinaryFile(filename, &ans_linear);
//        functions.outputBinaryFile(filename, &ans_cubic);
    } else if(work_type == 't') {
        printf("Please write a filename:\n");
        scanf("%s", filename);
        functions.outputTextFile(filename, &ans_linear);
//        functions.outputTextFile(filename, &ans_cubic);
    }

    printf("Thanks for your attention. \n");

    free(inputData.x->coordinates);
    free(inputData.y->coordinates);

    free(ans_linear.coordinates);
//    free(ans_cubic.coordinates);

    free(filename);

    return 0;
}
//








#ifndef C_PROJECT_INTERPOLATION_H
#define C_PROJECT_INTERPOLATION_H

#include <glob.h>

#define integer int
#define floating_point double
#define character char
#define file_t FILE*

struct DVector{
size_t dim;
floating_point *coordinates;
};
typedef struct DVector DVector;

struct Input_Data{
    int n;
    struct DVector *x, *y;
};
typedef struct Input_Data Input_Data;

class Functions{
public:
    DVector x, y;
    Input_Data inpuData = {0, &x, &y};
    DVector ans_linear;
    // DVector ans_cubic; 

    struct DVector Calculate(const struct Input_Data *inputData);

    struct DVector Interpolate(const struct Input_Data *inputData);

    floating_point power(floating_point x, integer n);
    floating_point fabs(floating_point x);
    void Jacobi(integer n, floating_point **matrix,floating_point *f, floating_point *result);
    struct DVector SolveLinSystem(floating_point** matrix, floating_point *vector, integer n);

    integer input(Input_Data *inputData);
    integer inputTextFile(char *file, Input_Data *inputData);

    void output (DVector *result);
    integer outputBinaryFile(char *file, DVector *result);
    integer outputTextFile(char *file, DVector *result);
};
#endif




#include <stdlib.h>
#include <stdio.h>
#include "../headers/interpolation.h"

DVector Functions:: Calculate(const struct Input_Data *inputData){
    if (inputData->n <=0) {
        printf("Your dataset is empty, just like your head, dude.\n");
        struct DVector erroneous = {0, NULL};
        return erroneous;
    }

    struct DVector res = {2};
    res.coordinates = (floating_point *) calloc(2, sizeof(floating_point));

    floating_point a_numerator = 0;
    floating_point a_denominator = 0;
    floating_point buff;
    integer nn = inputData->n;
    for (integer i = 0; i < nn; ++i) {
        buff = nn * inputData->x->coordinates[i] - 1;
        a_numerator   += inputData->y->coordinates[i] * buff;
        a_denominator += inputData->x->coordinates[i] * buff;
    }
    res.coordinates[0] = a_numerator / a_denominator;

    floating_point b_numerator = 0;
    for (integer i = 0; i < nn; ++i) {
        b_numerator += inputData->y->coordinates[i];
        b_numerator -= inputData->x->coordinates[i] * res.coordinates[0];
    }
    res.coordinates[1] = b_numerator / nn;

    return res;
}


DVector Functions::  Interpolate(const struct Input_Data *inputData){
    if (inputData->n <= 0) {
        printf("Your dataset is empty, just like your head, dude.\n");
        struct DVector erroneous = {0, NULL};
        return erroneous;
    }

    floating_point **matrix = (floating_point **) malloc(sizeof(floating_point) * 16);
    for (int i = 0; i < 4; ++i) {
        matrix[i] = (floating_point *) malloc(sizeof(floating_point) * 4);
    }

    floating_point *vector = (floating_point *) malloc(sizeof(floating_point) * 4);
    for (integer i = 0; i < 4; ++i) {
        vector[0] = 0;
    }

    floating_point *sum_xn = (floating_point *) calloc(6, sizeof(floating_point));
    for (integer i = 0; i < 6; ++i) {
        sum_xn[i] = 0;
    }

    for (integer i = 0; i < inputData->n; ++i) {
        for (integer j = 0; j < 6; ++j) {
            sum_xn[j] += power(inputData->x->coordinates[i], j + 1);
        }

        for (integer j = 0; j < 4; ++j) {
            vector[j] += inputData->y->coordinates[i] * power(inputData->x->coordinates[i], 3 - j);
        }
    }

    matrix[0][0] = sum_xn[5];

    matrix[1][0] = sum_xn[4];
    matrix[0][1] = sum_xn[4];

    matrix[2][0] = sum_xn[3];
    matrix[1][1] = sum_xn[3];
    matrix[0][2] = sum_xn[3];

    matrix[3][0] = sum_xn[2];
    matrix[2][1] = sum_xn[2];
    matrix[1][2] = sum_xn[2];
    matrix[0][3] = sum_xn[2];

    matrix[3][1] = sum_xn[1];
    matrix[2][2] = sum_xn[1];
    matrix[1][3] = sum_xn[1];

    matrix[3][2] = sum_xn[0];
    matrix[2][3] = sum_xn[0];

    matrix[3][3] = inputData->n;


    struct DVector res = SolveLinSystem(matrix, vector, 4);

    free(vector);
    for (integer i = 0; i < 4; ++i) {
        free(matrix[i]);
    }
    free(matrix);

    return res;
}

floating_point Functions::power(floating_point x, integer n){
    floating_point res = 1;
    for (int i = 0; i < n; ++i) {
        res *= x;
    }

    return res;
}

floating_point Functions::fabs(floating_point x){
    if (x >= 0) {
        return x;
    } else {
        return -1 * x;
    }
}

DVector Functions::SolveLinSystem(floating_point** matrix, floating_point *vector, integer n){
    struct DVector res = {n};
    res.coordinates = (floating_point *) calloc(res.dim, sizeof(floating_point));

    Jacobi(res.dim, matrix, vector, res.coordinates);

    return res;
}

void Functions::Jacobi (integer n, floating_point** matrix, floating_point* f, floating_point* result)
{
    const floating_point eps = 0.1;

    floating_point *TempX = (floating_point *) calloc(n, sizeof(floating_point));
    floating_point norm;

    do {
        for (integer i = 0; i < n; i++) {
            TempX[i] = f[i];
            for (integer g = 0; g < n; g++) {
                if (i != g)
                    TempX[i] -= matrix[i][g] * result[g];
            }
            TempX[i] /= matrix[i][i];
        }
        norm = fabs(result[0] - TempX[0]);
        for (int h = 0; h < n; h++) {
            if (fabs(result[h] - TempX[h]) > norm)
                norm = fabs(result[h] - TempX[h]);
            result[h] = TempX[h];
        }
    } while (norm > eps);
    free(TempX);
}

integer Functions::input(Input_Data *inputData){
    printf("How many (x,y) pairs will be there?\n");
    printf("Please note:\n");
    printf("x is height (cm)\n");
    printf("y is weight (kg)\n");
    scanf("%i", &inputData->n);
    if (inputData->n <= 0) {
        printf("dataset length must be greater than 0\n");
        return 1;
    }
    if (inputData->x == NULL
        | inputData->y == NULL) {
        printf("you have not provided any containers for dataset in your program");
        printf("\nSegmentation fault\n");
        return 1;
    }

    inputData->x->dim = inputData->n;
    inputData->y->dim = inputData->n;
    inputData->x->coordinates = (floating_point *) calloc(inputData->x->dim, sizeof(floating_point));
    inputData->y->coordinates = (floating_point *) calloc(inputData->y->dim, sizeof(floating_point));
    for (integer i = 0; i < inputData->n; ++i) {
        printf("x[%i]=", i+1);
        scanf("%lf", &inputData->x->coordinates[i]);

        printf("y[%i]=", i+1);
        scanf("%lf", &inputData->y->coordinates[i]);
    }

    return 0;
}

integer Functions::inputTextFile(char *file, Input_Data *inputData) {
    file_t input_file = fopen(file, "r");
    if (!input_file) {
        printf("error opening text file");
        return 1;
    }
    fseek(input_file, 0, SEEK_SET);
    fscanf(input_file, "%i", &inputData->n);

    if (inputData->n <= 0) {
        printf("dataset length must be greater than 0\n");
        return 1;
    }
    if (inputData->x == NULL
        | inputData->y == NULL) {
        printf("you have not provided any containers for dataset in your program");
        printf("\nSegmentation fault\n");
        return 1;
    }

    inputData->x->dim = inputData->n;
    inputData->y->dim = inputData->n;
    inputData->x->coordinates = (floating_point *) calloc(inputData->x->dim, sizeof(floating_point));
    inputData->y->coordinates = (floating_point *) calloc(inputData->y->dim, sizeof(floating_point));

    fseek(input_file, 1, SEEK_CUR);

    for (int i = 0; i < inputData->n; ++i) {
        fseek(input_file, 1, SEEK_CUR);
        fscanf(input_file, "%lf", &inputData->x->coordinates[i]);
    }

    fseek(input_file, 1, SEEK_CUR);

    for (int i = 0; i < inputData->n; ++i) {
        fseek(input_file, 1, SEEK_CUR);
        fscanf(input_file, "%lf", &inputData->y->coordinates[i]);
    }

    fclose(input_file);

    return 0;
}

void Functions::output(DVector *result) {
    printf("y=");
    for (integer i = 0; i < result->dim - 2; ++i) {
        printf("%.2fx^%i+",
               result->coordinates[i],
               (integer) result->dim - i - 1);
    }
    printf("%.2fx+", result->coordinates[result->dim - 2]);
    printf("%.2f\n", result->coordinates[result->dim - 1]);
}

int Functions::outputBinaryFile(char *file, DVector *result){
    file_t fout = fopen(file, "wb");
    if (!file) {
        printf("error opening binary file\n");
        return 1;
    }
    fseek(fout, 0, SEEK_END);
    fwrite(result, sizeof(floating_point), result->dim, fout);
    fclose(fout);

    return 0;
}

int Functions::outputTextFile(char *file, DVector *result){
    file_t fout = fopen(file, "a");
    if (!fout) {
        printf("error opening text file\n");
        return 1;
    }

    fseek(fout, 0, SEEK_END);

    fprintf(fout, "y=");
    for (integer i = 0; i < result->dim - 2; ++i) {
        fprintf(fout, "%.2fx^%i+", result->coordinates[i], (integer) result->dim - i - 1);
    }
    fprintf(fout, "%.2fx+", result->coordinates[result->dim - 2]);
    fprintf(fout, "%.2f\n", result->coordinates[result->dim - 1]);

    fclose(fout);

    return 0;
}   